#!/usr/bin/env python3
"""Export the Graph Pydantic schema to a JSON file.

Usage:
    python scripts/export_schema.py [--out docs/graph.schema.json] [--indent 2]

The script resolves the repository root automatically so it can be run from
any working directory inside the project.
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path

# Ensure the repository root is on sys.path when running from arbitrary dirs.
REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from app.models import Graph  # noqa: E402


def export_schema(output_path: Path, indent: int | None = 2) -> dict:
    schema = Graph.model_json_schema()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as fh:
        json.dump(schema, fh, indent=indent if indent and indent > 0 else None)
        fh.write("\n")
    return schema


def _ref_name(ref: str) -> str:
    return ref.split("/")[-1]


def _ts_type(field_schema: dict, definitions: dict) -> str:
    if "$ref" in field_schema:
        return _ref_name(field_schema["$ref"])
    if "anyOf" in field_schema:
        options = [_ts_type(opt, definitions) for opt in field_schema["anyOf"]]
        # dedupe while preserving order
        seen: list[str] = []
        for opt in options:
            if opt not in seen:
                seen.append(opt)
        return " | ".join(seen)
    if "type" not in field_schema:
        return "unknown"

    typ = field_schema["type"]
    if isinstance(typ, list):
        union = [_ts_type({"type": t}, definitions) for t in typ]
        return " | ".join(sorted(set(union)))

    if typ == "string":
        return "string"
    if typ in {"number", "integer"}:
        return "number"
    if typ == "boolean":
        return "boolean"
    if typ == "null":
        return "null"
    if typ == "array":
        item_schema = field_schema.get("items", {})
        return f"{_ts_type(item_schema, definitions)}[]"
    if typ == "object":
        props = field_schema.get("properties")
        additional = field_schema.get("additionalProperties")
        if props:
            # inline object literal
            lines = ["{"]
            required = set(field_schema.get("required", []))
            for key, schema_value in props.items():
                optional = "?" if key not in required else ""
                lines.append(
                    f"  {key}{optional}: {_ts_type(schema_value, definitions)};"
                )
            if additional:
                lines.append(
                    f"  [key: string]: {_ts_type(additional if isinstance(additional, dict) else {'type': 'unknown'}, definitions)};"
                )
            lines.append("}")
            return "\n".join(lines)
        if isinstance(additional, dict):
            return f"Record<string, {_ts_type(additional, definitions)}>"
        return "Record<string, unknown>"
    if "enum" in field_schema:
        return " | ".join(json.dumps(v) for v in field_schema["enum"])
    return "unknown"


def _emit_interface(name: str, schema_obj: dict, definitions: dict) -> list[str]:
    lines: list[str] = [f"export interface {name} {{"]
    properties = schema_obj.get("properties", {})
    required = set(schema_obj.get("required", []))
    for key, prop_schema in properties.items():
        optional = "?" if key not in required else ""
        ts_type = _ts_type(prop_schema, definitions)
        lines.append(f"  {key}{optional}: {ts_type};")

    additional = schema_obj.get("additionalProperties")
    if additional:
        if isinstance(additional, dict):
            ts_additional = _ts_type(additional, definitions)
        elif additional is True:
            ts_additional = "unknown"
        else:
            ts_additional = "unknown"
        lines.append(f"  [key: string]: {ts_additional};")
    lines.append("}")
    return lines


def export_typescript(schema: dict, output_path: Path) -> None:
    definitions: dict = schema.get("definitions", {})
    output_path.parent.mkdir(parents=True, exist_ok=True)

    sections: list[str] = [
        "/* eslint-disable @typescript-eslint/ban-types */",
        "// Auto-generated by scripts/export_schema.py; do not edit manually.",
        "",
    ]

    # Emit definitions (Node, Edge, etc.) first to satisfy references
    for def_name in sorted(name for name in definitions if definitions[name].get("type") == "object"):
        sections.extend(_emit_interface(def_name, definitions[def_name], definitions))
        sections.append("")

    # Emit root Graph interface
    sections.extend(_emit_interface("Graph", schema, definitions))
    sections.append("")
    sections.append("export type GraphPayload = Graph;")

    with output_path.open("w", encoding="utf-8") as ts_file:
        ts_file.write("\n".join(line for line in sections if line is not None))
        ts_file.write("\n")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Export Graph model JSON schema")
    parser.add_argument(
        "--out",
        type=Path,
        default=REPO_ROOT / "docs" / "graph.schema.json",
        help="Output path for the schema JSON file (default: docs/graph.schema.json)",
    )
    parser.add_argument(
        "--ts-out",
        type=Path,
        help="Optional path to also generate TypeScript definitions (e.g. web/src/types/graph.d.ts)",
    )
    parser.add_argument(
        "--indent",
        type=int,
        default=2,
        help="Indentation to use when writing JSON (default: 2, use 0 for compact)",
    )
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    schema = export_schema(args.out, indent=args.indent if args.indent is not None else 2)
    print(f"Schema exported to {args.out}")
    if args.ts_out:
        export_typescript(schema, args.ts_out)
        print(f"TypeScript definitions exported to {args.ts_out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
